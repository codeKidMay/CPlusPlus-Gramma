# C++语法学习项目 - Claude指令文档

## 项目概述
这是一个深度的C++语法学习项目，专为有经验的C++程序员设计，旨在系统学习C++11到C++20的现代特性，理解语言演进背后的设计思想和实现原理。

## 代码编写标准与要求

### 1. 总体原则
- **深度优先**：不讲基础语法，专注高级概念和底层实现原理
- **实用导向**：每个特性都要展示实际应用场景和最佳实践
- **性能意识**：分析不同实现方式的性能影响，提供基准测试
- **现代化**：体现现代C++的编程范式和设计哲学

### 2. 文件结构要求
每个语法点必须是独立的`.cpp`文件，包含以下结构：
```cpp
/**
 * C++XX [特性名称]深度解析
 * 
 * 核心概念：
 * 1. [概念1] - 简要说明
 * 2. [概念2] - 简要说明
 * 3. [概念3] - 简要说明
 * 4. [概念4] - 简要说明
 * 5. [概念5] - 简要说明
 */

#include <必要的头文件>

// ===== 1. [主题1]演示 =====
void demonstrate_topic1() {
    std::cout << "=== [主题1]演示 ===\n";
    // 详细的代码实现和解释
    std::cout << "\n";
}

// ===== 2. [主题2]演示 =====
// ... 更多主题

// ===== 主函数 =====
int main() {
    std::cout << "C++XX [特性名称]深度解析\n";
    std::cout << "========================\n";
    
    // 调用各个演示函数
    demonstrate_topic1();
    // ...
    
    return 0;
}

/*
编译和运行建议:
g++ -std=c++XX -O2 -Wall [filename].cpp -o [output]
./[output]

关键学习点:
1. [学习点1]
2. [学习点2]
...

注意事项:
- [重要注意事项]
*/
```

### 3. 内容深度要求

#### 3.1 概念解析层面
- **原理剖析**：解释特性的底层实现机制
- **设计动机**：说明为什么引入这个特性，解决了什么问题
- **编译器视角**：展示编译器如何处理这些特性
- **内存模型**：涉及内存布局、生命周期管理等

#### 3.2 代码示例层面
- **渐进式展示**：从简单到复杂，循序渐进
- **对比分析**：新旧方法对比，优缺点分析
- **错误演示**：展示常见错误和陷阱，以及正确做法
- **性能测试**：提供基准测试代码

#### 3.3 实际应用层面
- **设计模式**：特性在经典设计模式中的应用
- **库设计**：如何在库设计中合理使用这些特性
- **项目实战**：模拟真实项目场景的使用示例

### 4. 代码质量标准

#### 4.1 代码风格
- 使用现代C++风格（RAII、智能指针等）
- 变量命名清晰，函数职责单一
- 适当的注释，解释关键概念和技巧
- 遵循const正确性原则

#### 4.2 编译要求
- 必须能在指定的C++标准下编译通过
- 使用-Wall编译选项，无警告
- 支持-O2优化编译
- 如需链接库，在注释中明确说明

#### 4.3 运行时行为
- 输出结果清晰，便于理解概念
- 包含性能测试的代码要有合理的测试规模
- 多线程代码要考虑平台兼容性

### 5. 禁止事项
- **不要添加示例代码和测试代码**：专注核心功能实现
- **不要创建不必要的头文件**：除非确实需要跨文件共享
- **不要添加基础语法解释**：假设读者已具备C++基础
- **不要使用过时的编程风格**：避免C风格代码

### 6. 特定版本要求

#### C++11特性重点
- 右值引用与移动语义的深层机制
- Lambda表达式的闭包实现原理
- 智能指针的RAII设计哲学
- 变长模板的递归展开技巧
- 原子操作与内存模型
- 类型推导的规则和限制

#### C++14特性重点  
- 函数返回类型推导的限制和应用
- 广义Lambda捕获的实现技巧
- 变量模板的元编程应用
- constexpr函数的扩展能力

#### C++17特性重点
- 结构化绑定的编译器实现
- if constexpr的编译期分支
- 折叠表达式的参数包处理
- 类型安全容器的设计理念
- 并行算法的性能优化

#### C++20特性重点
- Concepts的约束系统设计
- Ranges的惰性求值机制  
- Coroutines的状态机实现
- Modules的编译模型革新

### 7. 文档化要求
每个重要概念都要包含：
- **使用场景**：什么时候应该使用这个特性
- **性能影响**：对编译时间和运行时性能的影响
- **最佳实践**：推荐的使用模式和注意事项
- **常见陷阱**：容易犯的错误和解决方案
- **演进历史**：特性的发展脉络和未来趋势

### 8. 质量保证检查清单
在创建新的语法文件时，请确认：

- [ ] 文件头注释包含核心概念列表
- [ ] 每个概念都有独立的演示函数
- [ ] 包含性能对比和最佳实践章节
- [ ] 代码可以独立编译运行
- [ ] 输出格式清晰易读
- [ ] 注释说明了关键学习点
- [ ] 避免了基础语法解释
- [ ] 体现了深度的技术洞察

### 9. 示例文件参考
参考已完成的C++11文件作为标准：
- `01_rvalue_references_move_semantics.cpp`
- `02_lambda_expressions.cpp`
- `03_smart_pointers_raii.cpp`

这些文件展现了所需的深度、广度和实用性。

---

**重要提醒**：本项目面向有经验的C++程序员，目标是深入理解现代C++的设计思想和最佳实践，而非基础语法教学。每个文件都应该能让读者对相关特性有更深层次的认识和掌握。